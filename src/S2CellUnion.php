<?php

class S2CellUnion {
	/**
	 * The CellIds that form the Union
	 *
	 * @var S2CellId[]
	 */
	private array $cellIds = [];

	/**
	 * @param S2CellId[] $cellIds
	 * @return void
	 */
	public function initFromCellIds(array $cellIds): void {
		$this->initRawCellIds($cellIds);
		$this->normalize();
	}

	/**
	 * Populates a cell union with the given S2CellIds or 64-bit cells ids, and
	 * then calls Normalize(). The InitSwap() version takes ownership of the
	 * vector data without copying and clears the given vector. These methods may
	 * be called multiple times.
	 *
	 * @param int[] $cellIds
	 */
	public function initFromIds(array $cellIds): void {
		$this->initRawIds($cellIds);
		$this->normalize();
	}

	/**
	 * @param $cellIds
	 * @return void
	 */
	public function initSwap($cellIds): void {
		$this->initRawSwap($cellIds);
		$this->normalize();
	}

	/**
	 * @param S2CellId[] $cellIds
	 * @return void
	 */
	public function initRawCellIds(array $cellIds): void {
		$this->cellIds = $cellIds;
	}

	/**
	 * @param int[] $cellIds
	 * @return void
	 */
	public function initRawIds(array $cellIds): void {
		$size = count($cellIds);
		$this->cellIds = range(0, $size);

		for ($i = 0; $i < $size; $i++) {
			$this->cellIds[] = new S2CellId($i);
		}
	}

	/**
	 * Like Init(), but does not call Normalize(). The cell union *must* be
	 * normalized before doing any calculations with it, so it is the caller's
	 * responsibility to make sure that the input is normalized. This method is
	 * useful when converting cell unions to another representation and back.
	 * These methods may be called multiple times.
	 *
	 * @param $cellIds
	 */
	public function initRawSwap($cellIds): void {
		$this->cellIds = $cellIds;
		// cellIds.clear();
	}

	/**
	 * @return int
	 */
	public function size(): int {
		return count($this->cellIds);
	}

	/** Enable iteration over the union's cells. */
	// @Override
//	  public Iterator<S2CellId> iterator() {
//	  return cellIds.iterator();
//	  }

	/** Direct access to the underlying vector for iteration . */
	public function cellIds(): array {
		return $this->cellIds;
	}

	/**
	 * Replaces "output" with an expanded version of the cell union where any
	 * cells whose level is less than "min_level" or where (level - min_level) is
	 * not a multiple of "level_mod" are replaced by their children, until either
	 * both of these conditions are satisfied or the maximum level is reached.
	 *
	 *  This method allows a covering generated by S2RegionCoverer using
	 * min_level() or level_mod() constraints to be stored as a normalized cell
	 * union (which allows various geometric computations to be done) and then
	 * converted back to the original list of cell ids that satisfies the desired
	 * constraints.
	 *
	 * @param $minLevel
	 * @param $levelMod
	 * @param $output
	 */
	public function denormalize($minLevel, $levelMod, &$output): void {
		// assert ($minLevel >= 0 && minLevel <= S2CellId.MAX_LEVEL);
		// assert ($levelMod >= 1 && $levelMod <= 3);

		$output = array();
		foreach ($this->cellIds as $id) {
			$level = $id->level();
			$newLevel = max($minLevel, $level);
			if ($levelMod > 1) {
				// Round up so that (new_level - min_level) is a multiple of level_mod.
				// (Note that S2CellId::kMaxLevel is a multiple of 1, 2, and 3.)
				$newLevel += (S2CellId::MAX_LEVEL - ($newLevel - $minLevel)) % $levelMod;
				$newLevel = min(S2CellId::MAX_LEVEL, $newLevel);
			}
			if ($newLevel === $level) {
				$output[] = $id;
			}
			else {
				$end = $id->childEnd($newLevel);
				for ($id->childBegin($newLevel); !$id->equals($end); $id = $id->next()) {
					$output[] = $id;
				}
			}
		}
	}

	/**
	 * If there are more than "excess" elements of the cell_ids() vector that are
	 * allocated but unused, reallocate the array to eliminate the excess space.
	 * This reduces memory usage when many cell unions need to be held in memory
	 * at once.
	 */
	public function pack(): void {
		$this->cellIds->trimToSize();
	}

	/**
	 * Return true if the cell union contains the given cell id. Containment is
	 * defined with respect to regions, e.g. a cell contains its 4 children. This
	 * is a fast operation (logarithmic in the size of the cell union).
	 *
	 * @param S2Cell|S2CellId|S2CellUnion|S2Point $that
	 * @return bool
	 */
	public function contains($that): bool {
		switch (get_class($that)) {
			case 'S2Cell':
				/** S2Cell $that */
				return $this->contains($that->getCellId());
			case 'S2CellId':
				// This function requires that Normalize has been called first.
				//
				// This is an exact test. Each cell occupies a linear span of the S2
				// space-filling curve, and the cell id is simply the position at the center
				// of this span. The cell union ids are sorted in increasing order along
				// the space-filling curve. So we simply find the pair of cell ids that
				// surround the given cell id (using binary search). There is containment
				// if and only if one of these two cell ids contains this cell.
				return $this->binarySearch($that);
			case 'S2CellUnion':
				// TODO(kirilll?): A divide-and-conquer or alternating-skip-search approach
				// may be significantly faster in both the average and worst case.
				foreach ($that as $id) {
					if (!$this->contains($id)) {
						return false;
					}
				}

				return true;
			case 'S2Point':
				return $this->contains(S2CellId::fromPoint($that));
		}

		return false;
	}

	/**
	 * @param S2CellId|S2CellUnion $that
	 * @return bool
	 */
	public function intersects($that): bool {
		switch (get_class($that)) {
			/**
			 * Return true if the cell union intersects the given cell id. This is a fast
			 * operation (logarithmic in the size of the cell union).
			 */
			case 'S2CellId':
				// This function requires that Normalize has been called first.
				// This is an exact test; see the comments for Contains() above.

				return $this->binarySearch($that);

			/**
			 * Return true if this cell union contain/intersects the given other cell
			 * union.
			 */
			case 'S2CellUnion':
				// TODO(kirilll?): A divide-and-conquer or alternating-skip-search approach
				// may be significantly faster in both the average and worst case.
				foreach ($that as $id) {
					if ($this->intersects($id)) {
						return true;
					}
				}

				return false;
		}

		return false;
	}

	/**
	 * @param S2CellUnion $x
	 * @param S2CellUnion $y
	 * @return void
	 */
	public function getUnion(S2CellUnion $x, S2CellUnion $y): void {
		// assert (x !== this && y !== this);
		$this->cellIds = [];

		$this->cellIds = array_merge($this->cellIds, $x->cellIds, $y->cellIds);

		$this->normalize();
	}

	/**
	 * @param S2CellUnion          $x
	 * @param S2CellId|S2CellUnion $y
	 * @return void
	 */
	public function getIntersection(S2CellUnion $x, $y): void {
		switch (get_class($y)) {
			/**
			 * Specialized version of GetIntersection() that gets the intersection of a
			 * cell union with the given cell id. This can be useful for "splitting" a
			 * cell union into chunks.
			 *
			 * @var S2CellId $y
			 */
			case 'S2CellId':
				// assert (x !== this);
				$this->cellIds = [];

				if ($x->contains($y)) {
					$this->cellIds[] = $y;
				}
				else {
					$pos = array_search($x->cellIds, $y->rangeMin()->id(), true);

					if ($pos === false) {
						return;
					}

					$idMax = $y->rangeMax();
					$size = count($x->cellIds);

					while ($pos < $size && $x->cellIds[$pos]->lessOrEquals($idMax)) {
						$this->cellIds[] = $x->cellIds[$pos++];
					}
				}
			break;
			/**
			 * Initialize this cell union to the union or intersection of the two given
			 * cell unions. Requires: x !== this and y !== this.
			 *
			 * @var S2CellUnion $y
			 */
			case 'S2CellUnion':
				// assert (x !== this && y !== this);

				// This is a fairly efficient calculation that uses binary search to skip
				// over sections of both input vectors. It takes constant time if all the
				// cells of "x" come before or after all the cells of "y" in S2CellId order.

				$this->cellIds = [];

				$i = 0;
				$j = 0;

				while ($i < count($x->cellIds) && $j < count($y->cellIds)) {
					$imin = $x->cellId($i)->rangeMin();
					$jmin = $y->cellId($j)->rangeMin();
					if ($imin->greaterThan($jmin)) {
						// Either j->contains(*i) or the two cells are disjoint.
						[$i, $j] = $this->containsOrDisjoint($x, $i, $y, $j, $imin);
					}
					else if ($jmin->greaterThan($imin)) {
						// Identical to the code above with "i" and "j" reversed.
						[$j, $i] = $this->containsOrDisjoint($y, $j, $x, $i, $imin);
					}
					else if ($x->cellId($i)->lessThan($y->cellId($j))) {
						$this->cellIds[] = $x->cellId($i++);
					}
					else {
						$this->cellIds[] = $y->cellId($j++);
					}
				}
				// The output is generated in sorted order, and there should not be any
				// cells that can be merged (provided that both inputs were normalized).
				// assert (!normalize());
			break;
		}
	}

	/**
	 * Just as normal binary search, except that it allows specifying the starting
	 * value for the lower bound.
	 *
	 * @param array    $l
	 * @param S2CellId $key
	 * @param int      $low
	 * @return int The position of the searched element in the list (if found), or the
	 *         position where the element could be inserted without violating the
	 *         order.
	 */
	private function indexedBinarySearch(array $l, S2CellId $key, int $low): int {
		$high = count($l) - 1;

		while ($low <= $high) {
			$mid = ($low + $high) >> 1;
			$midVal = $l[$mid];
			$cmp = $midVal->compareTo($key);

			if ($cmp < 0) {
				$low = $mid + 1;
			}

			else
				if ($cmp > 0) {
					$high = $mid - 1;
				}
				else {
					return $mid; // key found
				}
		}

		return $low; // key not found
	}

	/**
	 * @param int|S1Angle $that
	 * @param int|null    $maxLevelDiff
	 */
	public function expand($that, int $maxLevelDiff = null): void {

		/**
		 * Expands the cell union such that it contains all cells of the given level
		 * that are adjacent to any cell of the original union. Two cells are defined
		 * as adjacent if their boundaries have any points in common, i.e. most cells
		 * have 8 adjacent cells (not counting the cell itself).
		 *
		 *  Note that the size of the output is exponential in "level". For example,
		 * if $level === 20 and the input has a cell at level 10, there will be on the
		 * order of 4000 adjacent cells in the output. For most applications the
		 * Expand(min_fraction, min_distance) method below is easier to use.
		 */
		if (is_int($that)) {
			/** @var S2CellId[] $output */
			$output = [];
			$levelLsb = S2CellId::lowestOnBitForLevel($that);
			$i = $this->size() - 1;
			do {
				$id = $this->cellId($i);
				if ($id->lowestOnBit() < $levelLsb) {
					$id = $id->parent($that);
					// Optimization: skip over any cells contained by this one. This is
					// especially important when very small regions are being expanded.
					while ($i > 0 && $id->contains($this->cellId($i - 1))) {
						--$i;
					}
				}
				$output[] = $id;
				$id->getAllNeighbors($that, $output);
			} while (--$i >= 0);
			$this->initSwap($output);
		}

		/**
		 * Expand the cell union such that it contains all points whose distance to
		 * the cell union is at most minRadius, but do not use cells that are more
		 * than maxLevelDiff levels higher than the largest cell in the input. The
		 * second parameter controls the tradeoff between accuracy and output size
		 * when a large region is being expanded by a small amount (e.g. expanding
		 * Canada by 1km).
		 *
		 *  For example, if $maxLevelDiff === 4, the region will always be expanded by
		 * approximately 1/16 the width of its largest cell. Note that in the worst
		 * case, the number of cells in the output can be up to 4 * (1 + 2 **
		 * maxLevelDiff) times larger than the number of cells in the input.
		 */
		if ($that instanceof S1Angle) {
			$minLevel = S2CellId::MAX_LEVEL;
			foreach ($this as $id) {
				$minLevel = min($minLevel, $id->level());
			}
			// Find the maximum level such that all cells are at least "min_radius"
			// wide.
			$radiusLevel = S2Projections::MIN_WIDTH->getMaxLevel($minRadius->radians());
			if ($radiusLevel === 0 && $minRadius->radians() > S2Projections::MIN_WIDTH->getValue(0)) {
				// The requested expansion is greater than the width of a face cell.
				// The easiest way to handle this is to expand twice.
				$this->expand(0);
			}
			$this->expand(min($minLevel + $maxLevelDiff, $radiusLevel));
		}
	}

	/**
	 * @return S2CellUnion
	 * @Override
	 */
	public function clone(): S2CellUnion {
		$copy = new self();
		$copy->initRawCellIds($this->cellIds);

		return $copy;
	}

	/**
	 * @return S2Cap
	 * @Override
	 */
	public function getCapBound(): S2Cap {
		// Compute the approximate centroid of the region. This won't produce the
		// bounding cap of minimal area, but it should be close enough.
		if (empty($this->cellIds)) {
			return S2Cap::empty();
		}
		$centroid = new S2Point(0, 0, 0);
		foreach ($this as $id) {
			$area = (new S2Cell)->averageArea($id->level());
			$centroid = S2Point::add($centroid, S2Point::mul($id->toPoint(), $area));
		}
		if ($centroid->equals(new S2Point(0, 0, 0))) {
			$centroid = new S2Point(1, 0, 0);
		}
		else {
			$centroid = S2Point::normalize($centroid);
		}

		// Use the centroid as the cap axis, and expand the cap angle so that it
		// contains the bounding caps of all the individual cells. Note that it is
		// *not* sufficient to just bound all the cell vertices because the bounding
		// cap may be concave (i.e. cover more than one hemisphere).
		$cap = S2Cap::fromAxisHeight($centroid, 0);
		foreach ($this as $id) {
			$cap = $cap->addCap((new S2Cell($id))->getCapBound());
		}

		return $cap;
	}

	/**
	 * @return S2LatLngRect
	 * @Override
	 */
	public function getRectBound(): S2LatLngRect {
		$bound = S2LatLngRect::empty();
		foreach ($this as $id) {
			$bound = $bound->union((new S2Cell($id))->getRectBound());
		}

		return $bound;
	}

	/**
	 * This is a fast operation (logarithmic in the size of the cell union).
	 *
	 * @param S2Cell $cell
	 * @return bool
	 * @Override
	 */
	public function mayIntersect(S2Cell $cell): bool {
		return $this->intersects($cell->id());
	}

	/**
	 * The number of leaf cells covered by the union.
	 * This will be no more than 6*2^60 for the whole sphere.
	 *
	 * @return int the number of leaf cells covered by the union
	 */
	public function leafCellsCovered(): int {
		$numLeaves = 0;
		foreach ($this->cellIds as $cellId) {
			$invertedLevel = S2CellId::MAX_LEVEL - $cellId->level();
			$numLeaves += ((float)'1L' << ($invertedLevel << 1));
		}

		return $numLeaves;
	}

	/**
	 * Approximate this cell union's area by summing the average area of
	 * each contained cell's average area, using {@link S2Cell#averageArea()}.
	 * This is equivalent to the number of leaves covered, multiplied by
	 * the average area of a leaf.
	 * Note that {@link S2Cell#averageArea()} does not take into account
	 * distortion of cell, and thus may be off by up to a factor of 1.7.
	 * NOTE: Since this is proportional to LeafCellsCovered(), it is
	 * always better to use the other function if all you care about is
	 * the relative average area between objects.
	 *
	 * @return float the sum of the average area of each contained cell's average area
	 */
	public function averageBasedArea(): float {
		return (new S2Cell)->averageArea(S2CellId::MAX_LEVEL) * $this->leafCellsCovered();
	}

	/**
	 * Calculates this cell union's area by summing the approximate area for each
	 * contained cell, using {@link S2Cell#approxArea()}.
	 *
	 * @return float approximate area of the cell union
	 */
	public function approxArea(): float {
		$area = 0;
		foreach ($this->cellIds as $cellId) {
			$area += (new S2Cell($cellId))->approxArea();
		}

		return $area;
	}

	/**
	 * Calculates this cell union's area by summing the exact area for each
	 * contained cell, using the {@link S2Cell#exactArea()}.
	 *
	 * @return float the exact area of the cell union
	 */
	public function exactArea(): float {
		$area = 0;
		foreach ($this->cellIds as $cellId) {
			$area += (new S2Cell($cellId))->exactArea();
		}

		return $area;
	}

	/**
	 * Return true if two cell unions are identical.
	 *
	 * @param object $that
	 * @return bool
	 * @Override
	 */
	public function equals(object $that): bool {
		if (!$that instanceof self) {
			return false;
		}
		$union = $that;

		return $this->cellIds->equals($union->cellIds);
	}

	/**
	 * @return int
	 * @Override
	 */
	public function hashCode(): int {
		$value = 17;
		foreach ($this as $id) {
			$value = 37 * $value + $id->hashCode();
		}

		return $value;
	}

	/**
	 * Normalizes the cell union by discarding cells that are contained by other
	 * cells, replacing groups of 4 child cells by their parent cell whenever
	 * possible, and sorting all the cell ids in increasing order. Returns true if
	 * the number of cells was reduced.
	 *
	 *  This method *must* be called before doing any calculations on the cell
	 * union, such as Intersects() or Contains().
	 *
	 * @return true if the normalize operation had any effect on the cell union,
	 *         false if the union was already normalized
	 */
	public function normalize(): bool {
		// Optimize the representation by looking for cases where all subcells
		// of a parent cell are present.

		/** @var S2CellId[] $output */
		$output = array();
		sort($this->cellIds);

//      echo "\n\n\n";

//  foreach ($this->cellIds as $id) {
//      echo $id . "\n";
//  }

		foreach ($this->cellIds as $id) {
			$size = count($output);
			// Check whether this cell is contained by the previous cell.
			if ($size && $output[$size - 1]->contains($id)) {
				continue;
			}

			// Discard any previous cells contained by this cell.
			while (!empty($output) && $id->contains($output[count($output) - 1])) {
				unset($output[count($output) - 1]);
			}

			// Check whether the last 3 elements of "output" plus "id" can be
			// collapsed into a single parent cell.
			while (count($output) >= 3) {
				$size = count($output);
				// A necessary (but not sufficient) condition is that the XOR of the
				// four cells must be zero. This is also very fast to test.
				if (($output[$size - 3]->id() ^ $output[$size - 2]->id() ^ $output[$size - 1]->id()) !== $id->id()) {
					break;
				}

				// Now we do a slightly more expensive but exact test. First, compute a
				// mask that blocks out the two bits that encode the child position of
				// "id" with respect to its parent, then check that the other three
				// children all agree with "mask.
				$mask = $id->lowestOnBit() << 1;
				$mask = ~($mask + ($mask << 1));
				$idMasked = ($id->id() & $mask);
				if (($output[$size - 3]->id() & $mask) !== $idMasked
					|| ($output[$size - 2]->id() & $mask) !== $idMasked
					|| ($output[$size - 1]->id() & $mask) !== $idMasked || $id->isFace()) {
					break;
				}

				// Replace four children by their parent cell.
				unset($output[$size - 1], $output[$size - 2], $output[$size - 3]);
				$id = $id->parent();
			}
			$size = count($output);
			$output[$size] = $id;
		}

//      echo "===\n";
//      foreach ($output as $id) {
//          echo $id . "\n";
//      }
//      echo "\n";

		if (count($output) < $this->size()) {
			$this->initRawSwap($output);

			return true;
		}

		return false;
	}

	/**
	 * @param S2Cell|S2CellId|S2CellUnion $that
	 * @return bool
	 */
	private function binarySearch(S2CellId $that): bool {
		$pos = array_search($that, $this->cellIds, true);

		if ($pos < count($this->cellIds) && $this->cellIds[$pos + 1]->rangeMin()->lessOrEquals($that->rangeMax())) {
			return true;
		}

		return $pos !== 0 && $this->cellIds[$pos - 1]->rangeMax()->greaterOrEquals($that->rangeMin());
	}

	/**
	 * @param S2CellUnion $x
	 * @param int         $i
	 * @param S2CellUnion $y
	 * @param int         $j
	 * @param S2CellId    $min
	 * @return array
	 */
	private function containsOrDisjoint(S2CellUnion $x, int $i, S2CellUnion $y, int $j, S2CellId $min): array {
		if ($x->cellId($i)->lessOrEquals($y->cellId($j)->rangeMax())) {
			$this->cellIds[] = $x->cellId($i++);
		}
		else {
			// Advance "j" to the first cell possibly contained by *i.
			$j = $this->indexedBinarySearch($y->cellIds, $min, $j + 1);
			// The previous cell *($j-1) may now contain *i.
			if ($x->cellId($i)->lessOrEquals($y->cellId($j - 1)->rangeMax())) {
				--$j;
			}
		}

		return array($i, $j);
	}
}
